
קישור של MCP SDK - 
https://github.com/modelcontextprotocol/python-sdk


לבדוק - לא להוסיף עדיין.
שימוש ב RESOURCES בהעברת תוכן מסמכים ל-AI. Resources נטענים כחלק מה-context הראשוני (prompt), בעוד Tools דורשים קריאה אקטיבית. זה מפשט זרימות, חוסך round-trips, ומפחית מורכבות agentic.


בדיקה של הקוד עם MCP INSPECTOR, להבין אם נדרש להוריד את זה ישירות מתוך SDK.

--------

יש להשתמש ב-Sampling כברירת מחדל בכל מקרה שבו נדרש שימוש במודל שפה כחלק מהפעלת כלי. ה-MCP Server חייב להישאר רכיב תשתיתי שאינו מחזיק חיבור ישיר ל-LLM, אינו מנהל מפתחות API ואינו נושא בעלויות טוקנים או בסיכוני שימוש לרעה. האחריות להפעלת מודל השפה, לניהול ההרשאות ולעלות החישוב חייבת להיות בצד ה-Client, באמצעות Sampling.

בצד השרת, בתוך פונקציית ה-Tool, משתמשים בפונקציה createMessage כדי לבנות בקשה שמכילה messages (כלומר: הפרומפט/הודעות) שצריך להריץ על מודל השפה דרך הלקוח, והמטרה שלה היא לשלוח ל-Client “תריץ את ההודעות האלה על ה-LLM בשבילי” בלי שהשרת יתחבר ל-LLM ובלי שיחזיק מפתח API.

בצד הלקוח, כותבים sampling callback שמקבל את ה-messages שנשלחו מהשרת, והמטרה שלו היא לקרוא ל-Claude (או מודל אחר שהלקוח משתמש בו), להפיק טקסט, ולהחזיר לשרת תוצאה בפורמט של createMessageResult, כלומר את תוצאת יצירת הטקסט שה-LLM יצר עבור השרת.

--------

יש להשתמש ב-Logging ו-Progress Notifications בכל Tool שזמן הריצה שלו אינו מיידי. ה-MCP Server חייב לדווח ל-Client על התקדמות ולוגים בזמן אמת מתוך קוד הכלי עצמו, כדי למנוע חוסר ודאות, לשפר חוויית משתמש ולאפשר תפעול ודיבאג תקין. ה-Server אחראי אך ורק על שליחת מידע תשתיתי אמיתי לגבי מצב הריצה, בעוד שה-Client אחראי להחלטה האם וכיצד להציג מידע זה למשתמש. אין להסתמך על ה-LLM לצורך ניחוש סטטוס של כלים ארוכים, אלא להשתמש במנגנוני Logging ו-Progress כ-Telemetry רשמי של שכבת הביצוע.

בצד השרת, בתוך פונקציית ה-Tool מתקבל ארגומנט context (שמגיע אוטומטית כארגומנט האחרון), והמטרה שלו היא לאפשר שליחה בזמן אמת של לוגים והתקדמות ללקוח תוך כדי ריצה; משתמשים במתודה info כדי לשדר הודעות לוג, ומשתמשים במתודה reportProgress כדי לדווח על התקדמות ריצה, וכאשר קוראים למתודות האלה נשלחת הודעה אוטומטית ל-Client.

בצד הלקוח, כותבים logging callback שמטרתו לקבל מהשרת את הודעות הלוג ולהחליט איך להציג אותן למשתמש, וכותבים progress callback שמטרתו לקבל עדכוני התקדמות ולהציג אותם (למשל מד התקדמות); את logging callback מעבירים ל-client session, ואת progress callback מעבירים ל-callTool, ובתוך הקולבקים עצמם הלקוח מחליט האם להדפיס לטרמינל, להציג בדפדפן, או לא להציג בכלל.

--------

יש להשתמש ב-Roots (Routes) בכל Tool שניגש למערכת הקבצים של המשתמש. ה-MCP Server חייב לעבוד בתוך גבולות גישה מוגדרים מראש, שניתנים על-ידי המשתמש בעת הפעלת השרת, ואסור לו לגשת לקבצים או תיקיות מחוץ ל-Roots המותרים. Roots משמשים הן כמנגנון אבטחה תשתיתי והן ככלי שמאפשר ל-LLM להתמקד רק באזורים רלוונטיים במערכת הקבצים, מבלי לדרוש מהמשתמש לציין paths מלאים. האחריות לאכיפת הגישה ל-Roots היא של מפתח ה-MCP Server, ואין להסתמך על ה-SDK או על ה-LLM לצורך מניעת גישה לא מורשית.

פונקציות וכלים נדרשים – Roots / Routes
בצד ה-MCP Server

listRoutes()
מטרת הפונקציה היא להחזיר ל-Client ול-LLM את רשימת ה-Roots שהמשתמש התיר לשרת לגשת אליהם, כך שה-LLM יוכל להבין אילו אזורים במערכת הקבצים זמינים לפעולה.

readDirectory(path)
מטרת הפונקציה היא לקרוא את תוכן התיקייה המבוקשת ולאפשר ל-LLM לגלות קבצים קיימים, אך ורק אם הנתיב נמצא בתוך אחד ה-Roots המותרים.

convertVideo(path)
מטרת הפונקציה היא לבצע פעולה על קובץ (בדוגמה: המרת וידאו), ורק לאחר אימות שה-path שהתקבל נמצא בתוך Root מותר.

isPathAllowed(requestedPath)
מטרת פונקציית העזר הזו היא לאכוף בפועל את מדיניות ה-Roots, על-ידי בדיקה שה-path שה-Tool מנסה לגשת אליו כלול בתוך אחד ה-Roots שהוגדרו מראש, וחסימה מיידית של גישה מחוץ לגבולות אלו.

בצד ה-Client

אין פונקציות מיוחדות לאכיפת Roots בצד ה-Client. תפקיד ה-Client הוא לאפשר ל-LLM לקרוא ל-listRoutes, readDirectory ו-Tools אחרים לפי הצורך, ולהעביר את הקריאות ל-MCP Server. כל אכיפת הגישה בפועל מתבצעת בצד ה-Server בלבד.

--------


לינק עבור הסכמות של סוגי בקשות ודברים נוספים עבור MCP, מאותו הפרויקט אבל REPO אחר - 
https://github.com/modelcontextprotocol/modelcontextprotocol




בנה את ה־**Planner Node כ־Beam Search Planner**: בכל שלב תכנון, ה־Planner מייצר סט מועמדים (N) של פעולות/מיני־תוכניות אפשריות מה־State וה־Goal, מחשב לכל מועמד **ציון** באמצעות מנגנון ה־scoring הקיים (Risk/Cost/Benefit → `trade_off_score` + `recommendation`), ממיין את כל המועמדים לפי `trade_off_score` ומבצע את שלב ה־**Beam Search pruning**—שומר רק את **Top-K** (beam_width) ומוחק את כל היתר; לאחר מכן ה־Planner **מרחיב** רק את K המועמדים ששרדו לצעד הבא (generate→score→prune→expand) וחוזר על הלולאה לעומק מוגבל (למשל 2–3 צעדים) או עד עמידה בקריטריוני הצלחה/תקציב. הפעלת tools יקרים (RAG/Web/API) מתבצעת **רק אחרי pruning** ורק על מועמדים שעברו סף איכות/סיכון, כדי לשלוט בעלות ולמנוע בזבוז טוקנים; בסיום, ה־Planner בוחר את המועמד בעל הציון המצטבר הגבוה ביותר ככיוון המוביל, מעדכן את ה־State בתוצאות, וממשיך את התהליך עד להשגת ה־Goal.


from __future__ import annotations
משמש להפיכת type hints לעצלים (lazy evaluation), כך שאפשר להפנות לטיפוסים שעדיין לא הוגדרו בלי להשתמש במחרוזות. משתמשים בזה כשעובדים עם מחלקות שמפנות לעצמן או אחת לשנייה (כמו Trees, Graphs, Plans, States), ובעיקר בקוד מודרני עם type checking (IDE, mypy). היתרון: קוד נקי, קריא, ופחות תקלות בסידור תלות בין טיפוסים.
from dataclasses import dataclass
משמש ליצירת מחלקות נתונים קלות בלי לכתוב boilerplate. משתמשים בזה כשצריך לייצג state, תוצאה, קונפיגורציה או אובייקט תיאורי (למשל Plan, Action, Score). היתרון: פחות קוד, פחות באגים, מבנה ברור שמתאים במיוחד למערכות Agentic ו־AI.
from time import perf_counter
משמש למדידת זמני ריצה מדויקים ברזולוציה גבוהה. משתמשים בזה כשבודקים ביצועים, latency, או משווים בין אלגוריתמים (כמו decoding, beam search, planner loops). היתרון: מדידה אמינה ומדויקת, בניגוד ל־time.time, ומתאים ל־profiling ו־benchmarking בפרודקשן.


