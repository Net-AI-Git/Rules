---
description: "Standards for Pydantic schemas, data models, and structured interfaces"
alwaysApply: false
---

**See:** `@contract-scope-and-boundaries` for when to define explicit schemas (boundary points such as Agent↔Tool, LLM↔code).

## 0. When to Use dataclass vs Pydantic

* **Pydantic BaseModel:** Use for boundary schemas—Agent↔Tool, LLM↔Code, API contracts. Required for validation, serialization, and LLM binding. See Section 1 below.
* **dataclass:** Use for internal structures—state objects, config, results, descriptive objects (e.g., Plan, Action, Score). Less boilerplate, no validation overhead. See `@contract-scope-and-boundaries` for boundary vs internal distinction.
* **Rule:** At integration boundaries → Pydantic. Internal code → dataclass.

## 1. Schema Definition Standards
* **Base Class:** Always inherit from `pydantic.BaseModel` for all boundary data schemas (tools, LLM outputs, API contracts).
* **Field Descriptions:** Every field MUST include a `Field(description="...")`. This is critical for the LLM to understand the parameter's meaning.
* **Type Hints:** Use standard Python types (`str`, `int`, `float`, `bool`).

## 2. Enforcing Constraints
* **Restricted Values:** Use `typing.Literal` for fields with finite options (e.g., operation modes).
    * *Do not* use generic strings when options are finite.

## 3. Reusability & Serialization
* **Inheritance:** Create base classes for shared fields to avoid duplication.
* **Serialization:** Rely on Pydantic's built-in `.json()` and `.parse_raw()` methods.

## 4. Integration with LLMs & Tools
* **Binding:** Use `.bind_tools(tools=[Schema])` when connecting schemas to LLMs.
* **Structured Outputs:** Always use structured outputs for tools, defining the schema with Pydantic models.
* **Method:** Use `with_structured_output()` where applicable.
* **Extraction:** Access arguments via `response.tool_calls[0]['args']` rather than parsing raw strings.

## Code Example Pattern

```python
from pydantic import BaseModel, Field
from typing import Literal

class BaseToolInput(BaseModel):
    user_id: str = Field(description="The ID of the user triggering the action")

class WeatherQuery(BaseToolInput):
    location: str = Field(description="City and state, e.g. San Francisco, CA")
    unit: Literal['celsius', 'fahrenheit'] = Field(description="Temperature unit")
